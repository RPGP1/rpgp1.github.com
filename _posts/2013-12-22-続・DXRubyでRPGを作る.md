---
layout: post
date: 2013-12-22
title: 続・DXRubyでRPGを作る
---

[前回](http://rpgp1.github.io/2013-12-17/DXRubyでRPGを作る/ "[2013/12/17]DXRubyでRPGを作る")に続いて、DXRubyでRPGをどう作るか模索してみます。

### では早速、どんな構造に？

RPG要素は大方列挙しましたので、今度はそれを分類・分析します。本質的に被っている物を消していきましょう。

- Dataをまとめて保持
- Map/戦闘/Event Scene
- Map∋Area∋Squareで管理しScroll
- NPC
- Menu表示
- Eventの登録

すっきりしました。これを制御しなければならないので、ツリーを考えてみましょう。

    RPG-+--Scene-+--Map-+--Area-+--Square
        |        |      |       |
        |        |      |       +--NPC
        |        |      |
        |        |      +--Menu
        |        |
        |        +--Battle
        |        |
        |        +--Event(Animation)
        |       (|         )
        |       (+--Opening)
        |
        +--Data
        |
        +--Event

完全に正しいかどうかと言うのは、実際に作ってみなくては分かりません。「この仕組みだとこれこれが大変すぎる」「これ以上機能を増やすにはコードが汚い」ということになるかもしれません。

ただ、RPGのData管理部分を一つにまとめ、Eventも一元に管理し、SceneをMap/Battle/Eventに分け、MapはArea毎にSquareやNPCを設定し、表示するものとしてはそれ以外にメニューが有る。どうでしょうか？

では、簡単なものから私の考える実装を話します。

#### Data(モジュール)

Dataモジュールにはただひたすらにデータを保持させます。が、任意の名前で好きなデータを代入できる必要が有ります。そこで一工夫。

RubyのModuleには`missing_method(name, *args)`と言うメソッドが設定されています。そのモジュールに対して定義されていない名前のメソッドが呼び出された時に、その名前(Symbol)を`name`に、引数を`*args`に渡して代わりに呼び出されます。

さらに、Rubyで何か代入するときは`hensuu=`のような`=`で終わるメソッドが呼び出されています。

これらを組み合わせて、Dataモジュールは次のようにしてみました。

{% highlight ruby %}
module Data
  @@value = {} #Data格納用ハッシュ。変数名に値を対応させる。
  
  def self.method_missing(name,*args) #先ほど出ましたね
    if name.to_s =~ /[^=]=$/ #正規表現です。"="で終わっていたらtrue
      @@value[name.to_s[0...(name.to_s.size - 1)].to_sym] = args[-1]
      #nameから最後の"="を取った部分のSymbolに最後の引数を対応させました
      
    elsif @@value.has_key?(name) #"="で終わっていなくて、以前代入したことあるなら
      @@value[name] #その値を返します。
    else
      super #どちらでもなかったら元々の処理(NoMethodErrorのraise)
    end
  end
end
{% endhighlight %}

「おい！」思った人も多いでしょう。「こんなのただのハッシュだよ！`Data[:hensuu]=`と変わってないよ！」もっともな指摘です。

――――このままならね。

私はこれに2つ機能を加えました。

1. Group
2. List

Groupと言うのは、変数と並列でまたハッシュを作ることです。`Data[:Group][:GAgain][:hensuu]`と`Data.group.gAgain.hensuu`のどちらが直観的でしょう？

Listというのは、変数に対してそれが取りうる値を予め与えることで予期せぬ値を代入しないようにすることです。いちいち実装していたら大変ですよね。

ただ残念ながら、今回はその話をすると長くなりすぎるので詳しくはまた今度。

#### Event(モジュール)

Eventは任意の名前での登録は無いですが、情報を階層的に保持する点でDataと酷似するので省略します。こちらも、また今度。

#### Scene(モジュール)

Sceneの条件分岐はMap/Battle/Animationそれぞれのモジュールの方で.updateを定義しておけば簡単です。多少のテクニックが無くは無いですが、省略します。

#### Animaion(モジュール)/Opening(モジュール)

この部分はフレーム毎に呼び出すだけで、自由な演出ができるようにします。こちらから何かすると単なる制限になってしまう気がしてなりません。

#### Battle(モジュール)

まだ考えていません。RPGと言っても戦闘だけは何種類もあるので、その中で最低限の共通部分を模索しています。

#### Map(モジュール)

最後に持ってきたところからもうお分かりでしょうが、今日の山場です。

Mapは圧倒的に情報量が多いのです。それでも最終的にはゲームループに持ち込むのですが、

* Menuが出ているときは他の部分は停止させる
* Key入力に応じて主人公が移動する
* Main Characterと被らないようにNPCを動かす
* Main Characterが移動中ならスムーズにScrollする
* MenuのMenuに情報を伝える

など考慮しなければならない難問が多く有ります。それに、マップチップ情報やNPCの数はもはや不特定多数です。

しかし！そんな不特定多数のオブジェクトの制御をするのに参考になるものを、DXRubyの作者[mirichi氏](http://twitter.com/mirichi/ "@mirichi")が作っています。[DXRubyWS](http://github.com/mirichi/dxrubyws "GitHubに移動します")です。具体的には、オブジェクトツリーで上位にあるオブジェクトから順々に情報を伝えています。

DXRubyのマニュアルの`3.9 Spriteクラス`をご覧ください。次のような説明が有ります。

>Spriteクラスはゲームのキャラを扱う場合の基本となるクラスです。描画位置、描画パラメータ、画像データを保持し、自分自身を描画する機能を持ちます。

実はこれ、よくよく注意して読むと面白いことが分かります。`Sprite.update(ary)`と有るのに`Sprite#update`は無いのです。これは、Spriteが「[継承](http://e-words.jp/w/E7B699E689BF.html "既に定義されているクラスをもとに、拡張や変更を加えた新しいクラスを定義すること")」され、`#update`が定義されることを前提に作られているからです。

そしてDXRubyWSもそれを利用しています。WS(=Window System)を構成するあらゆるコントロールはこれを継承したWSControlまたはそのサブクラスなのです。そしてそれらを制御する際には、大きなものから小さなものへと情報が伝えられていきます。

これを応用するとどうなるでしょうか。ずばり、例えばMenuはMenuクラスで、NPCはNPCクラスでそれに特化したオブジェクトを生成し、`Map.update`時に順に`#update`が呼び出されるようにするのです。Menuオブジェクトは状況に応じてその配下のMenuオブジェクトの`#update`を呼び出します。この時に軽く条件分岐をするだけで、全体では複雑な制御が可能になります。

現在、この辺りを製作中です。詳しいことはまた細々とした記事になるでしょう。

### 終わりに

私は、私と同じようにRPGを作りたくなった人たちが再利用できるような、汎用なライブラリを作ろうとしています。先に話した制御構造を実現し、データを設定すれば基本的には使えるようにしたいのです。

それができれば、元々がプログラミング言語なので、RPGツクールのRGSSのようなものを作らなくても拡張性は最大です。すばらしいRPGが作られることでしょう。

現在、Data管理モジュール・Event管理モジュールが出来てはいます。Mapモジュールも少しずつ作っています。長い時間がかかると思いますが、学生が終わるまでには作り上げたいと思います。

最後まで読んで頂きありがとうございました。
