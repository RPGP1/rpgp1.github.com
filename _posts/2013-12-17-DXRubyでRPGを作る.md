---
layout: post
date: 2013-12-17
title: DXRubyでRPGを作る
---

ゲームの中でも最も色々な要素が絡みこむRPG。DXRubyで作るにはどうすればいいのか模索してみます。

### そもそもなぜDXRubyでRPGを作るのか

理由は次の3つです

* Rubyに魅かれた
* Gameに魅かれた
* DXRubyに魅かれた

それぞれ具体的に思うことを述べます。

#### Ruby

私はRubyに出会うまで、JavaScript→HTML/CSS→PHP→VBAと様々な形態のものを使っていました。(コンパイル言語は嫌いなのでやっていませんが。)その時に「これはどう表現するんだ？」というのが多く有りました。

しかしRubyという完全なるオブジェクト指向の言語は、簡潔で直観に近い構文や統一感のある構造のおかげか本当に生産性が高く感じられます。また"Enjoy Programming!"は学生として趣味でやるプログラミングにすごくフィットしています。

#### Game

また私は、ゲームほど人を楽しませるのに、Enjoyさせることに特化したプログラムは無いと思っています。現在の人々の娯楽の多くを占めているのも事実でしょう。

楽しんでプログラミングをしたい。ならば人を楽しませるものを作りたい。そう思っています。

#### DXRuby

そういう訳で、RubyでGameを作りたくなった私はDXRubyを選びました。

それは、Rubyの高生産性やオブジェクト指向に最もフィットしているからです。簡潔な構文やメソッドは見るだけでどんなものを作っているのかが分かり、サンプルが読みやすかったのも決め手の一つでした。

### RPGを考えよう

そろそろ本題に入りましょう。で、早速難問です。そもそもRPG要素とは何でしょうか？

様々な資料にあたって、最終的に大衆の作る世界最大の電子図書館Wikipediaを参考に次のような結論となりました。

+ Growth(成長要素)
+ Search(探索要素)
+ Collection(収集要素)
+ Effect(演出要素)

それぞれ分析していきましょう。

#### Growth(成長要素)

キャラクター(特に主人公)が成長しないRPGを私は知りません。皆さんにも「レベル上げ」や「ローラー」「～～狩り」などの言葉はなじみ深いのではないでしょうか？自分の努力によってキャラクターが強くなるのは嬉しいものです。

ここで必要になるものとしてまず、把握しやすいようにまとめてキャラクターのパラメータを保持しておく必要が有ります。

また、キャラクターを強くするものの代表は戦闘でしょう。多くのゲームが「新戦闘システム」を生み出そうとするなど、これがRPGの面白さの多くを担っているのは紛れもない事実です。

#### Search(探索要素)

ダンジョンのないRPGも、私は知りません。RPGと言えば広大な世界を冒険するものでは無いでしょうか。

そこで、マップを表示しスクロールさせる事になりますが、広大な世界を1枚の画像に入れ込んでそれをスクロールさせようとしたら、重くて仕方が有りません。マップの情報を縦と横のマス目で区切って管理することになります。

また、マップはマップで1つに管理することは問題が起こります。例えば、町の中でエンカウントはするべきではないでしょうし、時間を考えるのであれば町の中では時間経過を止めることもあるでしょう。ゲームにイベント配置するときにも、ある程度エリアで区切ってその中で何マス目かを指定する方が絶対簡単です。

では、マップの移動ができれば終わりでしょうか？そんなことは無く、メニューを表示させたり、自動移動するNPCと会話をしたりして情報の収集・管理をします。

その上で、面白いRPGにするなら世界はイベントなどによって変わるべきでしょう(ここに来ると‥‥/ここを調べると‥‥/等々)。

#### Collection(収集要素)

RPGのやりこみ要素の代表格は、アイテム収集かと思います。強い装備品などを集めることはストーリーの進展にも関わってきます。

プログラムの観点からこのシステムを考えると、アイテムデータをまとめて保持し、売買システムを構築し、(もしかすると「合成」や「錬金」といったものも実装し、)並べ替えにも対応させましょう。

私も見落としかけたのですが、一般のアイテムを拾うことによって得たりする場合は、一定の条件のもとで再出現させることも必要になってきます。

#### Effect(演出要素)

これはゲームの進行には関わりませんが、できるのであればイベントシーンや戦闘シーンは臨場感を持たせたいものです。エリア移動の時やオープニング画面など細かい部分にまで手を回せると、RPGとしての面白さが倍増していくことでしょう。

### ではどんな構造に？

RPG要素は大方列挙しましたので、今度はそれを分類・分析します。本質的に被っている物を消していきましょう。

- Dataをまとめて保持
- Map/戦闘/Event Scene
- Map∋Area∋Squareで管理しScroll
- NPC
- Menu表示
- Eventの登録

すっきりしました。これを制御しなければならないので、ツリーを考えてみましょう。

    RPG-+--Scene-+--Map-+--Area-+--Square
        |        |      |       |
        |        |      |       +--NPC
        |        |      |
        |        |      +--Menu
        |        |
        |        +--Battle
        |        |
        |        +--Event(Animation)
        |       (|         )
        |       (+--Opening)
        |
        +--Data
        |
        +--Event

完全に正しいかどうかと言うのは、実際に作ってみなくては分かりません。「この仕組みだとこれこれが大変すぎる」「これ以上機能を増やすにはコードが汚い」ということになるかもしれません。

ただ、RPGのData管理部分を一つにまとめ、Eventも一元に管理し、SceneをMap/Battle/Eventに分け、MapはArea毎にSquareやNPCを設定し、表示するものとしてはそれ以外にメニューが有る。どうでしょうか？

では、簡単なものから私の考える実装を話します。

#### Data(モジュール)

Dataモジュールにはただひたすらにデータを保持させます。が、任意の名前で好きなデータを代入できる必要が有ります。そこで一工夫。

RubyのModuleには`missing_method(name, *args)`と言うメソッドが設定されています。そのモジュールに対して定義されていない名前のメソッドが呼び出された時に、その名前(Symbol)を`name`に、引数を`*args`に渡して代わりに呼び出されます。

さらに、Rubyで何か代入するときは`hensuu=`のような`=`で終わるメソッドが呼び出されています。

これらを組み合わせて、Dataモジュールは次のようにしてみました。

{% highlighting ruby %}
module Data
  @@value = {} #Data格納用ハッシュ。変数名に値を対応させる。
  
  def self.method_missing(name,*args) #先ほど出ましたね
    if name.to_s =~ /[^=]=$/ #正規表現です。"="で終わっていたらtrue
      @@value[name.to_s[0...(name.to_s.size - 1)].to_sym] = args[-1]
      #nameから最後の"="を取った部分のSymbolに最後の引数を対応させました
      
    elsif @@value.has_key?(name) #"="で終わっていなくて、以前代入したことあるなら
      @@value[name] #その値を返します。
    else
      super #どちらでもなかったら元々の処理(NoMethodErrorのraise)
    end
  end
end
{% endhighlighting %}

「おい！」思った人も多いでしょう。「こんなのただのハッシュだよ！`Data[:hensuu]=`と変わってないよ！」もっともな指摘です。

――――このままならね。

私はこれに2つ機能を加えました。

1. Group
2. List

Groupと言うのは、変数と並列でまたハッシュを作ることです。`Data[:Group][:GAgain][:hensuu]`と`Data.group.gAgain.hensuu`のどちらが直観的でしょう？

Listというのは、変数に対してそれが取りうる値を予め与えることで予期せぬ値を代入しないようにすることです。いちいち実装していたら大変ですよね。

ただ残念ながら、今回はその話をすると長くなりすぎるので詳しくはまた今度。

#### Event(モジュール)

Eventは任意の名前での登録は無いですが、情報を階層的に保持する点でDataと酷似するので省略します。こちらも、また今度。

#### Scene(モジュール)

Sceneの条件分岐はMap/Battle/Animationそれぞれのモジュールの方で.updateを定義しておけば簡単です。多少のテクニックが無くは無いですが、省略します。

#### Animaion(モジュール)/Opening(モジュール)

この部分はフレーム毎に呼び出すだけで、自由な演出ができるようにします。こちらから何かすると単なる制限になってしまう気がしてなりません。

#### Battle(モジュール)

まだ考えていません。RPGと言っても戦闘だけは何種類もあるので、その中で最低限の共通部分を模索しています。

#### Map(モジュール)

最後に持ってきたところからもうお分かりでしょうが、今日の山場です。

Mapは圧倒的に情報量が多いのです。それでも最終的にはゲームループに持ち込むのですが、

* "メニューが出ているときは他の部分は停止させる"
* "入力に応じて主人公が移動する"
* "主人公と被らないようにNPCを動かす"
* "主人公が移動中ならスムーズにスクロールする"
* "メニューのメニューに情報を伝える"

など考慮しなければならない難問が多く有ります。それに、マップチップ情報やNPCの数はもはや不特定多数です。

しかし！そんな不特定多数のオブジェクトの制御をするのに参考になるものを、DXRubyの作者[mirichi氏](http://twitter.com/mirichi/ "@mirichi")が作っています。[DXRubyWS](http://github.com/mirichi/dxrubyws "GitHubに移動します")です。具体的には、オブジェクトツリーで上位にあるオブジェクトから順々に情報を伝えています。

DXRubyのマニュアルの`3.9 Spriteクラス`をご覧ください。次のような説明が有ります。

>Spriteクラスはゲームのキャラを扱う場合の基本となるクラスです。描画位置、描画パラメータ、画像データを保持し、自分自身を描画する機能を持ちます。

実はこれ、よくよく注意して読むと面白いことが分かります。`Sprite.update(ary)`と有るのに`Sprite#update`は無いのです。これは、Spriteが「[継承](http://e-words.jp/w/E7B699E689BF.html "既に定義されているクラスをもとに、拡張や変更を加えた新しいクラスを定義すること")」され、`#update`が定義されることを前提に作られているからです。

そしてDXRubyWSもそれを利用しています。WS(=Window System)を構成するあらゆるコントロールはこれを継承したWSControlまたはそのサブクラスなのです。そしてそれらを制御する際には、大きなものから小さなものへと情報が伝えられていきます。

これを応用するとどうなるでしょうか。ずばり、例えばMenuはMenuクラスで、NPCはNPCクラスでそれに特化したオブジェクトを生成し、`Map.update`時に順に`#update`が呼び出されるようにするのです。Menuオブジェクトは状況に応じてその配下のMenuオブジェクトの`#update`を呼び出します。この時に軽く条件分岐をするだけで、全体では複雑な制御が可能になります。

現在、この辺りを製作中です。詳しいことはまた細々とした記事になるでしょう。

### 終わりに

私は、私と同じようにRPGを作りたくなった人たちが再利用できるような、汎用なライブラリを作ろうとしています。先に話した制御構造を実現し、データを設定すれば基本的には使えるようにしたいのです。

それができれば、元々がプログラミング言語なので、RPGツクールのRGSSのようなものを作らなくても拡張性は最大です。すばらしいRPGが作られることでしょう。

現在、Data管理モジュール・Event管理モジュールが出来てはいます。Mapモジュールも少しずつ作っています。長い時間がかかると思いますが、学生が終わるまでには作り上げたいと思います。

最後まで読んで頂きありがとうございました。
